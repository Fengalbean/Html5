<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
    <meta content="telephone=no" name="format-detection">
    <meta content="email=no" name="format-detection">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-touch-fullscreen" content="yes"/>
    <title>history-api</title>
    <link rel="stylesheet" href="../bootstrap/css/bootstrap.min.css">
</head>
<body>
<div class="container">
    <article>
        <h1>History - api</h1>
        <p  class="h4">
            <strong>在HTML 5中，新增了一个History API，该API通过脚本语言来管理浏览器的历史记录，该API中关于如何通过脚本来实现浏览器历史记录的前后导航的部分已经在HTML 5之前得到实现。</strong>
        </p>
        <p class="h4"> <strong>在HTML 5中，新增了通过脚本语言在浏览器历史记录中添加项目的功能，以及在不刷新页面的前提下显式地改变浏览器地址栏中的URL地址的功能，同时添加了一个当用户单击浏览器的后退按钮时触发的事件。通过这些新增的功能与事件，可以实现在不刷新页面的前提下动态地改变浏览器地址栏中的URL地址，动态修改页面上所显示资源的功能动态修改页面上所显示资源的功能。</strong></p>
    </article>
    <div class="row" style="margin-top: 40px;">
        <div class="col-md-3">
            <ul class="list-group">
                <li class="list-group-item active" id="history"><h4>history API介绍</h4></li>
                <li class="list-group-item" id="pushState"><h4>pushState方法</h4></li>
                <li class="list-group-item" id="replaceState"><h4>replaceState</h4></li>
                <li class="list-group-item" id="popstate"><h4>popstate事件</h4></li>
            </ul>
        </div>
        <div class="col-md-9">
            <div class="panel panel-default">
                <div class="panel-heading"><h4>History API介绍</h4></div>
                <div class="panel-body" id="content">

                </div>
            </div>

        </div>
    </div>
</div>

<script src="../jquery/2.2.3/jquery.min.js"></script>
<script>

    $(document).ready(function () {

    	var $content = $('#content');
    	var historyStr = '<br><p >在HTML 5中，新增了一个History API，该API通过脚本语言来管理浏览器的历史记录，该API中关于如何通过脚本来实现浏览器历史记录的前后导航的部分已经在HTML 5之前得到实现。</p><br><p >在HTML 5中，新增了通过脚本语言在浏览器历史记录中添加项目的功能，以及在不刷新页面的前提下显式地改变浏览器地址栏中的URL地址的功能，同时添加了一个当用户单击浏览器的后退按钮时触发的事件。通过这些新增的功能与事件，可以实现在不刷新页面的前提下动态地改变浏览器地址栏中的URL地址，动态修改页面上所显示资源的功能</p>';

    	var pushStateStr = '<p><strong >pushState() ：</strong>带有三个参数：一个状态对象，一个标题（现在被忽略了），以及一个可选的URL地址。下面将对这三个参数进行细致的检查：</p> <p><strong >state object ：</strong>— 状态对象是一个由 pushState()方法创建的、与历史纪录相关的JS对象。当用户定向到一个新的状态时，会触发popstate事件。事件的state属性包含了历史纪录的state对象。（译者注：总而言之，它存储JSON字符串，可以用在popstate事件中。）state 对象可以是任何可以序列化的东西。由于 火狐 会将这些对象存储在用户的磁盘上，所以用户在重启浏览器之后这些state对象会恢复，我们施加一个最大640k 的字符串在state对象的序列化表示上。如果你像pushState() 方法传递了一个序列化表示大于640k 的state对象，这个方法将扔出一个异常。如果你需要更多的空间，推荐使用sessionStorage或者localStorage。 </p> <p> <strong >title ：</strong>— 火狐浏览器现在已经忽略此参数，将来也许可能被使用。考虑到将来有可能的改变，传递一个空字符串是安全的做法。当然，你可以传递一个短标题给你要转变成的状态。（译者注：现在大多数浏览器不支持或者忽略这个参数，最好用null代替） </p> <p> <strong >URL ：</strong>— 这个参数提供了新历史纪录的地址。请注意，浏览器在调用pushState()方法后不会去加载这个URL，但有可能在之后会这样做，比如用户重启浏览器之后。新的URL不一定要是绝对地址，如果它是相对的，它一定是相对于当前的URL。新URL必须和当前URL在同一个源下;否则，pushState() 将丢出异常。这个参数可选，如果它没有被特别标注，会被设置为文档的当前URL。 </p>';

    	var popstateStr = '';
    	// 点击history API介绍
        $('#history').on('click',function () {
            $(this).addClass('active').siblings('.active').removeClass('active');
			$content.html(historyStr);
			history.pushState({'history':'history'},'history','#hisory')
		});
        // 点击history API介绍
		$('#pushState').on('click',function () {
			$(this).addClass('active').siblings('.active').removeClass('active');
			$content.html(pushStateStr);
			history.pushState({'history':'pushState'},'pushState','#pushState')
		});
        // 点击history popstate事件
		$('#popstate').on('click',function () {
			$(this).addClass('active').siblings('.active').removeClass('active');
			$content.html(pushStateStr);
			history.pushState({'history':'pushState'},'pushState','#pushState')
		});
		// 点击history 相关属性
		$('#historyAttr').on('click',function () {
			$(this).addClass('active').siblings('.active').removeClass('active');
			$content.html(pushStateStr);
			history.pushState({'history':'pushState'},'pushState','#pushState')
		});
        // 点击旧API
		$('#oldHistory').on('click',function () {
			$(this).addClass('active').siblings('.active').removeClass('active');
			$content.html(pushStateStr);
			history.pushState({'history':'pushState'},'pushState','#pushState')
		});

        // 监听state事件
		window.addEventListener('popstate',function (event) {
			var keys = getKeys(event.state);
			if (event.state && keys > 0) {

            }
            console.log(keys);

		});

		/**
         * 获取object keys
		 * @param obj
		 * @returns {Array}
		 */
		function getKeys(obj) {
        	var result = [];
            for(var key in obj) {
            	if (obj.hasOwnProperty(key)) {
					result.push(key);
                }
            }
            return result;
		}

		/**
         * 检测数据类型
		 * @param obj
		 * @returns {string}
		 */
		function type(obj) {
            return Object.prototype.toString.call(obj).slice(8,-1).toLocaleLowerCase();
		}

		function extend(origin,target) {
            for (var key in target) {
            	if (target.hasOwnProperty(key)){
					origin[key] = target[key]
                }
            }
            return origin;
		}

        function LazyTpl(obj) {

			var defaultConfig = {
				// 字段列表
				head: [],
                // 渲染数据源
                list: [{}],
                // 渲染类型
                type: 'table',
                // 处理每列数据的闭包函数
                func: function () {

				}
            };

			extend(defaultConfig,obj);

			// 渲染的数据
			this.list = defaultConfig.list ;

			// 标题数据
            this.head = defaultConfig.head;

			// 渲染模板类型
			this.type = defaultConfig.type || ['table','ul','ol','canvas'];

			this.func = defaultConfig.func
		}



		// 生成html
		LazyTpl.prototype.generalHtml = function (type) {

		};

		/**
		 * 生成头html标签
		 * @param headList
		 * @returns {string}
		 */
		LazyTpl.prototype.buildTableHead = function (headList) {

			// 头字段必须是数组
			if (type(headList) !== 'array') {
				new TypeError('headList is not Array!');
			}
			var tbHeadAttr = '',
				tbHead = '';

			var i = 0,
				l = headList.length;
			for ( ; i < l; i++) {
				tbHeadAttr += '<th>' + headList[i] + '</th>';
			}
			tbHead = '<thead><tr>'+ tbHeadAttr + '</thead></tr>';
			return tbHead;
		};

		/**
		 * 拼接表格BodyHtml
		 * @param list
		 * @param callback
		 * @returns {string}
		 */
		LazyTpl.prototype.buildTableBody = function (list,callback) {
			// 头字段必须是数组
			if (type(list) !== 'array') {
				new TypeError('list is not Array!');
			}
			var tbBody= '';
			var i = 0,
				l = list.length;
			for ( ; i < l; i++) {

				var str = '';// 用来存储每一行数组

				for (var key in list[i]) { // 组装一行里面所有的列
					if (list[i].hasOwnProperty(key)) {

						if (callback) {
							str += '<td>' + callback(list[i][key]) + '</td>';
						} else {
							str += '<td>' + list[i][key] + '</td>';
						}

					}
				}

				// 把所有行都组装到tbody中去
				tbBody += '<tr>' + str +'</tr>';

			}
			return tbBody;
		};
		/**
		 * 组装表格html
		 * @returns {string}
		 */
		LazyTpl.prototype.buildTable = function () {
			return this.buildTableHead(this.head) + this.buildTableBody(this.list);
		};

        var tpl = new LazyTpl();
	})
</script>
</body>
</html>
